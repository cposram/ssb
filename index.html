
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>蛋蛋明星大亂鬥 - Egg Smash</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            font-family: Arial, sans-serif;
            touch-action: manipulation;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 70vh;
            border: 4px solid #fff;
        }
        /* 手機控制介面 */
        #controls {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 600px;
            margin-top: 20px;
        }
        .btn-group { display: flex; gap: 10px; }
        .ctrl-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            touch-action: none;
            border: 2px solid #555;
        }
        .ctrl-btn:active { background: #fff; transform: scale(0.9); }
        .attack-btn { background: #ff4757; color: white; width: 70px; height: 70px; }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
        }
        .hp-bar-container { width: 150px; height: 20px; background: #555; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        .hp-fill { width: 100%; height: 100%; background: #2ed573; transition: width 0.2s; }
        .label { color: white; text-shadow: 1px 1px 2px black; text-align: center; margin-bottom: 5px; font-weight: bold;}
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-overlay">
        <div>
            <div class="label">玩家 (Player)</div>
            <div class="hp-bar-container"><div id="p1-hp" class="hp-fill"></div></div>
        </div>
        <div>
            <div class="label">電腦 (NPC)</div>
            <div class="hp-bar-container"><div id="p2-hp" class="hp-fill" style="background: #ff4757;"></div></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <div class="btn-group">
            <div class="ctrl-btn" id="btn-left">←</div>
            <div class="ctrl-btn" id="btn-right">→</div>
        </div>
        <div class="btn-group">
            <div class="ctrl-btn" id="btn-jump">跳</div>
            <div class="ctrl-btn attack-btn" id="btn-attack">砍</div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 設定畫布大小
    canvas.width = 800;
    canvas.height = 500;

    // 遊戲物理常數
    const gravity = 0.8;
    const friction = 0.8;

    // 平台數據
    const platforms = [
        { x: 150, y: 380, w: 500, h: 20 }, // 主地板
        { x: 100, y: 250, w: 150, h: 15 }, // 左台階
        { x: 550, y: 250, w: 150, h: 15 }, // 右台階
        { x: 325, y: 150, w: 150, h: 15 }  // 中高台階
    ];

    class Egg {
        constructor(x, y, color, isNPC) {
            this.x = x;
            this.y = y;
            this.width = 40;
            this.height = 50;
            this.color = color;
            this.dx = 0;
            this.dy = 0;
            this.hp = 100;
            this.isNPC = isNPC;
            this.facing = 1; // 1是右, -1是左
            this.isAttacking = false;
            this.attackCooldown = 0;
            this.jumpCount = 0;
        }

        draw() {
            // 畫武器 (如果有攻擊)
            if (this.isAttacking) {
                ctx.fillStyle = "#ddd";
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.facing * Math.PI / 4);
                ctx.fillRect(0, -5, 50 * this.facing, 10);
                ctx.strokeRect(0, -5, 50 * this.facing, 10);
                ctx.restore();
            }

            // 畫蛋身
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(this.x + this.width/2, this.y + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();

            // 畫眼睛
            ctx.fillStyle = "#000";
            let eyeX = this.x + (this.facing === 1 ? 25 : 10);
            ctx.beginPath();
            ctx.arc(eyeX, this.y + 15, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            // 重力
            this.dy += gravity;
            this.x += this.dx;
            this.y += this.dy;
            this.dx *= friction;

            // 平台碰撞檢測
            let onGround = false;
            platforms.forEach(p => {
                if (this.x + this.width > p.x && this.x < p.x + p.w &&
                    this.y + this.height > p.y && this.y + this.height < p.y + p.h + this.dy) {
                    if (this.dy >= 0) {
                        this.dy = 0;
                        this.y = p.y - this.height;
                        onGround = true;
                        this.jumpCount = 0;
                    }
                }
            });

            // 邊界限制
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
            if (this.y > canvas.height) { // 摔下場外
                this.hp -= 1; 
                this.y = 0;
                this.dy = 0;
            }

            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.attackCooldown < 15) this.isAttacking = false;
        }

        attack() {
            if (this.attackCooldown === 0) {
                this.isAttacking = true;
                this.attackCooldown = 30;
                return true;
            }
            return false;
        }
    }

    const player = new Egg(200, 300, "#FFF", false);
    const npc = new Egg(550, 300, "#FFD700", true);

    // 控制輸入邏輯
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    // 手機按鈕邏輯
    function setupMobileBtn(id, actionDown, actionUp) {
        const btn = document.getElementById(id);
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); actionDown(); });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); if(actionUp) actionUp(); });
    }

    let mobileLeft = false;
    let mobileRight = false;

    setupMobileBtn('btn-left', () => mobileLeft = true, () => mobileLeft = false);
    setupMobileBtn('btn-right', () => mobileRight = true, () => mobileRight = false);
    setupMobileBtn('btn-jump', () => { if(player.jumpCount < 2) { player.dy = -12; player.jumpCount++; } });
    setupMobileBtn('btn-attack', () => { player.attack(); });

    function handleInput() {
        if (keys['ArrowLeft'] || mobileLeft) {
            player.dx = -5;
            player.facing = -1;
        }
        if (keys['ArrowRight'] || mobileRight) {
            player.dx = 5;
            player.facing = 1;
        }
        if (keys['Space'] || keys['ArrowUp']) {
            if (player.jumpCount < 1) { // 簡單一段跳
                player.dy = -12;
                player.jumpCount = 2; // 防止連跳
            }
        }
        if (keys['KeyZ'] || keys['ControlLeft']) {
            player.attack();
        }
    }

    function updateAI() {
        // 簡單 AI：追蹤玩家並在距離近時攻擊
        const dist = player.x - npc.x;
        if (Math.abs(dist) > 60) {
            npc.dx = dist > 0 ? 3 : -3;
            npc.facing = dist > 0 ? 1 : -1;
        } else {
            if (Math.random() < 0.05) npc.attack();
        }

        // 隨機跳躍
        if (Math.random() < 0.01 && npc.jumpCount === 0) {
            npc.dy = -12;
            npc.jumpCount = 1;
        }
    }

    function checkHit(attacker, victim) {
        if (attacker.isAttacking && attacker.attackCooldown === 25) {
            const hitRange = 60;
            const attackerMidX = attacker.x + attacker.width/2;
            const reach = attackerMidX + (attacker.facing * hitRange);
            
            if (victim.x < Math.max(attackerMidX, reach) && 
                victim.x + victim.width > Math.min(attackerMidX, reach) &&
                Math.abs(attacker.y - victim.y) < 50) {
                
                victim.hp -= 10;
                victim.dx = attacker.facing * 15; // 擊飛效果
                victim.dy = -5;
                
                // 更新血條
                document.getElementById(attacker.isNPC ? 'p2-hp' : 'p1-hp').style.width = attacker.hp + '%';
                document.getElementById(victim.isNPC ? 'p2-hp' : 'p1-hp').style.width = victim.hp + '%';
            }
        }
    }

    function drawStage() {
        // 畫競技場背景與平台
        ctx.fillStyle = "#747d8c";
        platforms.forEach(p => {
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeStyle = "#2f3542";
            ctx.strokeRect(p.x, p.y, p.w, p.h);
        });
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        handleInput();
        updateAI();

        player.update();
        npc.update();

        checkHit(player, npc);
        checkHit(npc, player);

        drawStage();
        player.draw();
        npc.draw();

        if (player.hp <= 0) alert("你輸了！再接再厲！");
        else if (npc.hp <= 0) alert("你贏了！蛋蛋之王！");
        else requestAnimationFrame(gameLoop);
    }

    // 重置遊戲
    if (player.hp > 0 && npc.hp > 0) {
        gameLoop();
    }

</script>
</body>
</html>
