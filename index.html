<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>忍者：極限滑動</title>
    <style>
        /* 防止下拉重整導致的誤觸，並優化手機體驗 */
        body { 
            margin: 0; padding: 0; overflow: hidden; background: #000; 
            touch-action: none; font-family: sans-serif;
            overscroll-behavior-y: contain; /* 允許系統下拉重整，但不影響遊戲內滾動 */
        }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #050505; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI 層 */
        #ui { position: absolute; top: 0; width: 100%; pointer-events: none; padding: 15px; box-sizing: border-box; }
        .bars { display: flex; justify-content: space-between; }
        .hp-box { width: 40%; }
        .hp-bg { height: 12px; background: #333; border-radius: 6px; border: 1px solid #fff; overflow: hidden; }
        .hp-fill { height: 100%; width: 100%; transition: width 0.3s; }
        #level-tag { color: gold; font-weight: bold; font-size: 20px; text-align: center; }
        
        #combo-info { position: absolute; left: 20px; bottom: 100px; color: #ff3e3e; font-size: 45px; font-weight: 900; opacity: 0; font-style: italic; text-shadow: 2px 2px #fff; }
        
        /* 結局畫面 */
        #msg-screen { 
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); 
            display: none; flex-direction: column; align-items: center; justify-content: center; 
            color: #fff; z-index: 100; pointer-events: auto;
        }
        .btn { padding: 15px 40px; background: #2ecc71; border: none; border-radius: 30px; color: #fff; font-size: 20px; font-weight: bold; margin-top: 20px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui">
        <div class="bars">
            <div class="hp-box">
                <div style="color:#2ecc71; font-size:12px;">NINJA</div>
                <div class="hp-bg"><div id="p1-hp" class="hp-fill" style="background:#2ecc71"></div></div>
            </div>
            <div id="level-tag">第 1 關</div>
            <div class="hp-box" style="text-align:right;">
                <div style="color:#e74c3c; font-size:12px;">BOSS</div>
                <div class="hp-bg"><div id="p2-hp" class="hp-fill" style="background:#e74c3c"></div></div>
            </div>
        </div>
    </div>
    
    <div id="combo-info">0 COMBO!</div>
    <canvas id="c"></canvas>

    <div id="msg-screen">
        <h1 id="status-title" style="font-size: 40px;"></h1>
        <p id="reward-text"></p>
        <button class="btn" onclick="next()">繼續挑戰</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    
    // 自適應解析度
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    let stage = 1;
    let active = true;
    let combo = 0;
    let comboT = 0;
    
    // 物理常數
    const G = 0.6;
    const F = 0.85;

    // 玩家與數值
    let player = {
        x: 50, y: 300, w: 30, h: 50, dx: 0, dy: 0,
        hp: 500, maxHp: 500, dmg: 25, range: 80,
        color: '#00ff88', invinc: 0
    };

    let boss = {
        x: 0, y: 300, w: 40, h: 60, dx: 0, dy: 0,
        hp: 300, maxHp: 300, dmg: 15,
        color: '#ff3e3e', cd: 0
    };

    let platforms = [];
    function initStage() {
        player.x = 50; player.y = 100; player.dx = 0; player.dy = 0;
        boss.maxHp = 200 * Math.pow(1.5, stage-1);
        boss.hp = boss.maxHp;
        boss.x = canvas.width - 100;
        
        // 隨機生成平台
        platforms = [
            {x: 0, y: canvas.height - 60, w: canvas.width, h: 60}, // 地板
            {x: canvas.width*0.2, y: canvas.height*0.6, w: 120, h: 10},
            {x: canvas.width*0.6, y: canvas.height*0.4, w: 120, h: 10}
        ];
        document.getElementById('level-tag').innerText = `第 ${stage} 關`;
    }

    // 觸控邏輯
    let tStart = {x:0, y:0};
    canvas.addEventListener('touchstart', e => {
        tStart.x = e.touches[0].clientX;
        tStart.y = e.touches[0].clientY;
    });

    canvas.addEventListener('touchend', e => {
        let tEnd = {x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY};
        let dx = tEnd.x - tStart.x;
        let dy = tEnd.y - tStart.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 15) {
            attack(); // 點擊 = 攻擊
        } else {
            if (Math.abs(dx) > Math.abs(dy)) {
                // 左右滑動 = 衝刺
                player.dx = dx > 0 ? 20 : -20;
                player.invinc = 10;
            } else if (dy < -30) {
                // 上滑 = 跳躍
                if (Math.abs(player.dy) < 0.1) player.dy = -15;
            }
        }
    });

    function attack() {
        if (!active) return;
        let hit = Math.abs(player.x - boss.x) < player.range && Math.abs(player.y - boss.y) < 60;
        if (hit) {
            let d = player.dmg * (1 + combo * 0.1);
            boss.hp -= d;
            combo++;
            comboT = 60;
            createEffect(boss.x, boss.y, '#fff');
        }
    }

    function createEffect(x, y, color) {
        // 簡單的受擊閃爍效果
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 40, 0, Math.PI*2);
        ctx.fill();
    }

    function update() {
        if (!active) return;

        // 玩家物理
        player.dy += G;
        player.dx *= F;
        player.x += player.dx;
        player.y += player.dy;
        if (player.invinc > 0) player.invinc--;

        // Boss AI
        let dist = player.x - boss.x;
        if (Math.abs(dist) > 60) boss.dx = dist > 0 ? 2 : -2;
        else {
            boss.dx = 0;
            if (boss.cd <= 0) {
                if (player.invinc <= 0) player.hp -= boss.dmg;
                boss.cd = 60;
                createEffect(player.x, player.y, 'red');
            }
        }
        if (boss.cd > 0) boss.cd--;
        boss.dy += G;
        boss.x += boss.dx;
        boss.y += boss.dy;

        // 碰撞檢測
        [player, boss].forEach(o => {
            platforms.forEach(p => {
                if (o.x+o.w > p.x && o.x < p.x+p.w && o.y+o.h > p.y && o.y+o.h < p.y+p.h+o.dy) {
                    if (o.dy > 0) { o.dy = 0; o.y = p.y - o.h; }
                }
            });
            if (o.x < 0) o.x = 0;
            if (o.x > canvas.width - o.w) o.x = canvas.width - o.w;
        });

        // Combo 邏輯
        if (comboT > 0) {
            comboT--;
            document.getElementById('combo-info').style.opacity = 1;
            document.getElementById('combo-info').innerText = combo + " COMBO!";
        } else {
            combo = 0;
            document.getElementById('combo-info').style.opacity = 0;
        }

        // UI 更新
        document.getElementById('p1-hp').style.width = (player.hp / player.maxHp * 100) + '%';
        document.getElementById('p2-hp').style.width = (boss.hp / boss.maxHp * 100) + '%';

        // 勝負判斷
        if (player.hp <= 0 || boss.hp <= 0) {
            active = false;
            document.getElementById('msg-screen').style.display = 'flex';
            document.getElementById('status-title').innerText = player.hp <= 0 ? "戰死沙場" : "斬殺成功";
            document.getElementById('reward-text').innerText = player.hp <= 0 ? "勤加修練，下拉重整再來！" : "獲得神兵利器，傷害永久提升！";
            if (boss.hp <= 0) player.dmg += 10;
        }
    }

    function draw() {
        ctx.fillStyle = '#050505';
        ctx.fillRect(0,0,canvas.width, canvas.height);

        // 畫平台
        ctx.fillStyle = '#222';
        platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

        // 畫忍者 (帶殘影)
        if (player.invinc > 0) ctx.globalAlpha = 0.5;
        ctx.shadowBlur = 15; ctx.shadowColor = player.color;
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.w, player.h);
        ctx.globalAlpha = 1.0;

        // 畫 Boss
        ctx.shadowColor = boss.color;
        ctx.fillStyle = boss.color;
        ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
        ctx.shadowBlur = 0;

        update();
        requestAnimationFrame(draw);
    }

    function next() {
        if (player.hp <= 0) {
            location.reload();
        } else {
            stage++;
            active = true;
            document.getElementById('msg-screen').style.display = 'none';
            initStage();
        }
    }

    initStage();
    draw();
</script>
</body>
</html>
